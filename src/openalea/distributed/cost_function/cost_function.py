#----------------------------------------------------
#   Cache Data selection
#----------------------------------------------------


# A data is save on site SC if p(t, SE, SC) < threshold
def compute_p(task, transfer_rate, 
              site_exec, site_cache, site_input):
    """ Compute the value p(t, SE, SC)
    Inputs: 
    [float] exec_time: the time to execute the task (in sec)
    [float] s_input: the size of the inputs of the task (in MB)
    [float] s_output: the size of the outputs generated by the task (in MB)
    [list of list of float] transfer_rate: the transfer rate between sites (in B/sec) where trasnfer_rate[0][1] is the trasnfer rate between site 0 and 1
    [int] site_exec: ID of the site where the task is executed
    [int] site_cache: ID of the site where the data would be cached
    [int] site_input: ID of the site where the input data is

    Outputs:
    [float]: the value p computed
    """
    # task
    exec_time=task['exec_time']
    s_input=task['s_input']
    s_output=task['s_output']
    # the time to serialize data is (in B/sec) 
    writing_time = transfer_rate[0][0]
    
    t_write_output = s_output / writing_time
    t_get_input = s_input / transfer_rate[site_input][site_exec]
    t_compute = exec_time
    t_get_output = s_output / transfer_rate[site_exec][site_cache]
    
    p = ( t_write_output ) / (t_get_input + t_compute - t_get_output)
    return p
    
# decision on caching
def cache_data_selection(task, 
                         transfer_rate, site_exec, 
                         site_cache, site_input, threshold):
    p=compute_p(task, transfer_rate, site_exec, site_cache, site_input)
    if p < 0.:
        return 0
    if p< threshold:
        return 1
    else:
        return 0

#----------------------------------------------------
#   Cache Site Selection
#----------------------------------------------------

def cache_site_selection(task, site_info, transfer_rate, site_exec,
                        method):
    """ Get the site where the data will be stored
    Inputs:
    [dict] site_info: metadata of the sites
    [list of list of float] transfer_rate: the transfer rate between sites (in MB/sec) where trasnfer_rate[0][1] is the trasnfer rate between site 0 and 1
    [int] site_exec: ID of the site where the task is executed
    # [bool] cache_data_decision: decision on storing data or not
    [str] method: method of site selection (bStorage or bCompute)
    
    Ouputs:
    [int]: ID of the site where the data will be stored
    """
    #task
    s_output = task['s_output']
    
    # list of site with enough storage to store the cache:
#     site_available = site_info.keys()
    site_full = []
    for s in site_info:
        if site_info[s]['storage_available'] < s_output:
            # remove the site from available sites
#             site_available.pop(s)
            site_full.append(s)

    if site_full == site_info.keys():
        print "No site has enough data storage - By default stored at site 0"
        print "TODO: manage this case"

    costs = []
    for s in site_info:
        if s in site_full:
            c=0.
        else:
            t_send_output = s_output / transfer_rate[site_exec][s]
            c = (compute_bStorage(site_info, s)) / (t_send_output)
        costs.append(c)

    f = lambda i: costs[i]
    cache_site = max(range(len(costs)), key=f)
    return cache_site


def compute_bStorage(site_info, s):
    bStorage = (site_info[s]["storage_available"]) / (site_info[s]["storage_total"])
    return bStorage

def compute_bCompute(site_info, s):
    bCompute = 1 / site_info[s]['cpus']
    return bCompute
    
    
#----------------------------------------------------
#   Execution site selection
#----------------------------------------------------

def get_waiting_time(site_info, s):
    """ Get the expected waiting time to have access to site s for execution
    Inputs:
    [dict] site_info: metadata of the sites
    [int] s: site 
    
    Outputs:
    [float]: expected waiting time
    """
    # get the list of worker at site s
    workers_waiting_time = []
    worker_ids = site_info[s]['workers']
    for w in worker_ids:
        worker_id = "worker_"+str(w)
        worker = site_info[s][worker_id]
        workers_waiting_time.append(worker)
    return min(workers_waiting_time)
    

def execution_site_selection(task, 
                             site_exec, site_info, transfer_rate):
    """ Get the time to execute the task at site site_exec
    Inputs:
    [float] exec_time: the time to execute the task (in sec)
    [float] s_input: the size of input data (in MB)
    [int] site_input: ID of the site where input data is
    [int] site_exec: ID of the site where the task is executed
    [dict] site_info: metadata of sites (include site_wait= time to wait to get resource)
    [list of list of float] transfer_rate: the transfer rate between sites (in MB/sec) where trasnfer_rate[0][1] is the trasnfer rate between site 0 and 1
    
    Outputs:
    [float]: time to execute the task at site 
    """
    # task
    exec_time=task['exec_time']
    s_input=task['s_input']
    site_input=task['site_input']
    
    t_get_input = s_input / transfer_rate[site_input][site_exec]
    t_compute = exec_time
    site_wait = get_waiting_time(site_info, site_exec)
    
    time_compute = t_get_input + t_compute + site_wait
    
    return time_compute
    

#----------------------------------------------------
#   Cost function
#----------------------------------------------------

def compute_cost(site_info, transfer_rate, task, method, threshold,
                 cache_data_decision, cache_site_decision, site_exec):
    """ Compute the total cost
    Inputs:
    [dict] site_info: metadata of the sites
    [list of list of float] transfer_rate: the transfer rate between sites (in MB/sec) where trasnfer_rate[0][1] is the trasnfer rate between site 0 and 1
    [dict] task: metadata of the task to execute
    [str] method: cache_site_method to use
    [float] threshold: the threshold of cache data decision
    [bool] cache_data_selection: decision on cache or not
    [int] cache_site_decision: ID of site where data will be cached
    [int] site_exec: ID of site where task is executed
    
    Outputs:
    [float]: total cost
    """
    # get task metadata 
    exec_time=task["exec_time"]
    s_input=task["s_input"] 
    site_input=task["site_input"]
    s_output=task["s_output"]
    
    cost_exec = execution_site_selection(task=task, 
                                         site_exec=site_exec, 
                                         site_info=site_info, 
                                         transfer_rate=transfer_rate)

    cost_cache_sj = cache_data_decision * s_output / transfer_rate[site_exec][cache_site_decision]
    total_cost = cost_exec + cost_cache_sj
    
    return total_cost

def get_selection(site_info, transfer_rate, task, method, threshold):
    """ Get the best combination of the 3 parameters: SE, SC, e
    Inputs:
    [dict] site_info: metadata of the sites
    [list of list of float] transfer_rate: the transfer rate between sites (in MB/sec) where trasnfer_rate[0][1] is the trasnfer rate between site 0 and 1
    [dict] task: metadata of the task to execute
    [str] method: cache_site_method to use
    [float] threshold: the threshold of cache data decision
    
    Outputs:
    [int]: ID of the site to execute
    [int]: ID of the site to cache
    [bool]: decision on cache or not
    """
    # get task metadata 
    exec_time=task["exec_time"]
    s_input=task["s_input"] 
    site_input=task["site_input"]
    s_output=task["s_output"]
    
    # the cost of executing the task at site Si and cache at site Sj costs[Si][Sj]
    costs=[]
    for site_exec in sites:
        cache_site_decision = cache_site_selection(task=task,
                                         site_info=sites, 
                                         transfer_rate=transfer_rate,
                                         site_exec=site_exec,
                                         method=method)
        cache_data_decision = cache_data_selection(task=task, 
                                         transfer_rate=transfer_rate, 
                                         site_exec=site_exec, 
                                         site_cache=cache_site_decision,
                                         site_input=site_input, 
                                         threshold=threshold)
        cost_si = compute_cost(site_info, transfer_rate, task, method, threshold,
                 cache_data_decision, cache_site_decision, site_exec)
        
        costs.append([cost_si, site_exec, cache_site_decision, cache_data_decision])
        
#     print costs
    c = min(costs)
    total_cost=c[0]
    se=c[1]
    sc=c[2]
    d=c[3]
    return total_cost, se, sc, d

    